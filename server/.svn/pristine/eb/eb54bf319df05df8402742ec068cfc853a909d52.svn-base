using System;
using System.Collections;
using Server;
using Server.Targeting;
using Server.Mobiles;
using Server.Commands;
using System.Collections.Generic;
using Server.Scripts.Custom.Citizenship;

namespace Server.Factions
{
	[CustomEnum( new string[]{ "Lillano", "Pedran", "Arbor", "Calor", "Vermell" } )]
	public abstract class Town : IComparable
	{
		private TownDefinition m_Definition;
		private TownState m_State;

		public TownDefinition Definition
		{
			get{ return m_Definition; }
			set{ m_Definition = value; }
		}

		public TownState State
		{
			get{ return m_State; }
			set{ m_State = value; ConstructGuardLists(); }
		}

		public int Silver
		{
			get{ return m_State.Silver; }
			set{ m_State.Silver = value; }
		}

        public ICommonwealth OwningCommonwealth
        {
            get { return m_State.MyCommonwealth; }
            set { m_State.MyCommonwealth = value; }
        }
        public Mobile Minister
        {
            get { return m_State.Minister; }
            set { m_State.Minister = value; }
        }
		public Faction Militia 
		{
			get{ return m_State.Militia; }
			set{ Capture( value ); }
		}

		public static readonly TimeSpan IncomePeriod = TimeSpan.FromDays( 1.0 );

		public static Town FromRegion( Region reg )
		{
			if ( reg.Map != Faction.Facet )
				return null;

			List<Town> towns = Towns;

			for ( int i = 0; i < towns.Count; ++i )
			{
				Town town = towns[i];

				if ( reg.IsPartOf( town.Definition.Region ) )
					return town;
			}

			return null;
		}
        public static Town FromMilitia(Faction militia)
        {
            if (militia == null)
                return null;

            foreach (Town town in Towns)
            {
                if (town.Militia == militia)
                    return town;
            }

            return null;
        }
	
		public DateTime LastIncome
		{
			get{ return m_State.LastIncome; }
			set{ m_State.LastIncome = value; }
		}

		public ArrayList BuildFinanceList()
		{
			ArrayList list = new ArrayList();

			List<VendorList> vendorLists = VendorLists;

			for ( int i = 0; i < vendorLists.Count; ++i )
				list.AddRange( vendorLists[i].Vendors );

			List<GuardList> guardLists = GuardLists;

			for ( int i = 0; i < guardLists.Count; ++i )
				list.AddRange( guardLists[i].Guards );

			return list;
		}

		private List<VendorList> m_VendorLists;
		private List<GuardList> m_GuardLists;

		public List<VendorList> VendorLists
		{
			get{ return m_VendorLists; }
			set{ m_VendorLists = value; }
		}

		public List<GuardList> GuardLists
		{
			get{ return m_GuardLists; }
			set{ m_GuardLists = value; }
		}

		public void ConstructGuardLists()
		{
			GuardDefinition[] defs = ( Militia == null ? new GuardDefinition[0] : Militia.Definition.Guards );

			m_GuardLists = new List<GuardList>();

			for ( int i = 0; i < defs.Length; ++i )
				m_GuardLists.Add( new GuardList( defs[i] ) );
		}

		public GuardList FindGuardList( Type type )
		{
			List<GuardList> guardLists = GuardLists;

			for ( int i = 0; i < guardLists.Count; ++i )
			{
				GuardList guardList = guardLists[i];

				if ( guardList.Definition.Type == type )
					return guardList;
			}

			return null;
		}

		public void ConstructVendorLists()
		{
			VendorDefinition[] defs = VendorDefinition.Definitions;

			m_VendorLists = new List<VendorList>();

			for ( int i = 0; i < defs.Length; ++i )
				m_VendorLists.Add( new VendorList( defs[i] ) );
		}

		public VendorList FindVendorList( Type type )
		{
			List<VendorList> vendorLists = VendorLists;

			for ( int i = 0; i < vendorLists.Count; ++i )
			{
				VendorList vendorList = vendorLists[i];

				if ( vendorList.Definition.Type == type )
					return vendorList;
			}

			return null;
		}

		public bool RegisterGuard( BaseFactionGuard guard )
		{
			if ( guard == null )
				return false;

			GuardList guardList = FindGuardList( guard.GetType() );

			if ( guardList == null )
				return false;

			guardList.Guards.Add( guard );
			return true;
		}

		public bool UnregisterGuard( BaseFactionGuard guard )
		{
			if ( guard == null )
				return false;

			GuardList guardList = FindGuardList( guard.GetType() );

			if ( guardList == null )
				return false;

			if ( !guardList.Guards.Contains( guard ) )
				return false;

			guardList.Guards.Remove( guard );
			return true;
		}

		public bool RegisterVendor( BaseFactionVendor vendor )
		{
			if ( vendor == null )
				return false;

			VendorList vendorList = FindVendorList( vendor.GetType() );

			if ( vendorList == null )
				return false;

			vendorList.Vendors.Add( vendor );
			return true;
		}

		public bool UnregisterVendor( BaseFactionVendor vendor )
		{
			if ( vendor == null )
				return false;

			VendorList vendorList = FindVendorList( vendor.GetType() );

			if ( vendorList == null )
				return false;

			if ( !vendorList.Vendors.Contains( vendor ) )
				return false;

			vendorList.Vendors.Remove( vendor );
			return true;
		}

		public static void Initialize()
		{
			List<Town> towns = Towns;

			for ( int i = 0; i < towns.Count; ++i )
			{
                towns[i].Minister = towns[i].Minister;
			}

			CommandSystem.Register( "GrantTownSilver", AccessLevel.Administrator, new CommandEventHandler( GrantTownSilver_OnCommand ) );
		}

		public Town()
		{
			m_State = new TownState( this );
			ConstructVendorLists();
			ConstructGuardLists();
		}
        public bool IsMinister(Mobile mob)
        {
            if (mob == null || mob.Deleted)
                return false;
            return (mob.AccessLevel >= AccessLevel.GameMaster || mob == Minister);
        }
		public static List<Town> Towns { get { return Reflector.Towns; } }

		public const int SilverCaptureBonus = 10000;

		public void Capture( Faction f )
		{
			if ( m_State.Militia == f )
				return;

			if ( m_State.Militia == null ) // going from unowned to owned
			{
				LastIncome = DateTime.Now;
				f.Silver += SilverCaptureBonus;
			}
			else if ( f == null ) // going from owned to unowned
			{
				LastIncome = DateTime.MinValue;
			}
			else // otherwise changing hands, income timer doesn't change
			{
				f.Silver += SilverCaptureBonus;
			}

			m_State.Militia = f;

			List<VendorList> vendorLists = VendorLists;

			for ( int i = 0; i < vendorLists.Count; ++i )
			{
				VendorList vendorList = vendorLists[i];
				List<BaseFactionVendor> vendors = vendorList.Vendors;

				for ( int j = vendors.Count - 1; j >= 0; --j )
					vendors[j].Delete();
			}

			List<GuardList> guardLists = GuardLists;

			for ( int i = 0; i < guardLists.Count; ++i )
			{
				GuardList guardList = guardLists[i];
				List<BaseFactionGuard> guards = guardList.Guards;

				for ( int j = guards.Count - 1; j >= 0; --j )
					guards[j].Delete();
			}

			ConstructGuardLists();
		}

		public int CompareTo( object obj )
		{
			return m_Definition.Sort - ((Town)obj).m_Definition.Sort;
		}

		public override string ToString()
		{
			return m_Definition.FriendlyName;
		}

		public static void WriteReference( GenericWriter writer, Town town )
		{
			int idx = Towns.IndexOf( town );

			writer.WriteEncodedInt( (int) (idx + 1) );
		}

		public static Town ReadReference( GenericReader reader )
		{
			int idx = reader.ReadEncodedInt() - 1;

			if ( idx >= 0 && idx < Towns.Count )
				return Towns[idx];

			return null;
		}

		public static Town Parse( string name )
		{
			List<Town> towns = Towns;

			for ( int i = 0; i < towns.Count; ++i )
			{
				Town town = towns[i];

				if ( Insensitive.Equals( town.Definition.FriendlyName, name ) )
					return town;
			}

			return null;
		}

		public static void GrantTownSilver_OnCommand( CommandEventArgs e )
		{
			Town town = FromRegion( e.Mobile.Region );

			if ( town == null )
				e.Mobile.SendMessage( "You are not in a faction town." );
			else if ( e.Length == 0 )
				e.Mobile.SendMessage( "Format: GrantTownSilver <amount>" );
			else
			{
				town.Silver += e.GetInt32( 0 );
				e.Mobile.SendMessage( "You have granted {0:N0} silver to the town. It now has {1:N0} silver.", e.GetInt32( 0 ), town.Silver );
			}
		}
	}
}